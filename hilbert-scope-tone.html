<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hilbert Scope with Tone.js</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: #000;
        color: #fff;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }

      #canvas {
        border: 1px solid #333;
        background: #000;
        margin: 20px 0;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin: 10px 0;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 20px;
        background: #333;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      button:hover {
        background: #555;
      }

      button:disabled {
        background: #666;
        cursor: not-allowed;
      }

      .keyboard {
        display: flex;
        gap: 5px;
        margin: 20px 0;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 800px;
      }

      .key {
        width: 60px;
        height: 120px;
        background: #fff;
        color: #000;
        border: 2px solid #333;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 10px;
        font-weight: bold;
        transition: all 0.1s;
      }

      .key.black {
        background: #222;
        color: #fff;
        height: 80px;
        width: 50px;
        margin: 0 -28px;
        z-index: 2;
      }

      .key:not(.black):hover {
        background: #f0f0f0;
      }

      .key.black:hover {
        background: #444;
      }

      .key.active {
        background: #56a652 !important;
        transform: translateY(2px);
      }

      .key.black.active {
        background: #347d31 !important;
      }

      .info {
        text-align: center;
        margin: 10px 0;
        max-width: 600px;
      }

      .status {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
        background: #333;
      }

      .options {
        display: flex;
        gap: 20px;
        margin: 10px 0;
        align-items: center;
      }

      .option {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      input[type="range"] {
        width: 100px;
      }

      label {
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>Hilbert Scope with Tone.js</h1>
    <div class="info">
      <p>
        The Hilbert Scope is a circular, squiggly object whose size and shape
        follow the volume and timbre of the sound. Click the keys below or use
        your computer keyboard (A-K for white keys, W-E-T-Y-U for black keys) to
        play notes.
      </p>
    </div>

    <div class="controls">
      <button id="startBtn">Start Audio</button>
      <button id="stopBtn" disabled>Stop Audio</button>
    </div>

    <div class="options">
      <div class="option">
        <label for="volumeSlider">Volume:</label>
        <input type="range" id="volumeSlider" min="0" max="100" value="75" />
        <span id="volumeValue">75%</span>
      </div>
      <div class="option">
        <label for="octaveSelect">Octave:</label>
        <select id="octaveSelect">
          <option value="2">C2-B2</option>
          <option value="3">C3-B3</option>
          <option value="4" selected>C4-B4</option>
          <option value="5">C5-B5</option>
          <option value="6">C6-B6</option>
        </select>
      </div>
    </div>

    <div id="status" class="status">Click "Start Audio" to begin</div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="keyboard" id="keyboard">
      <!-- Keys will be generated by JavaScript -->
    </div>

    <script>
      /**
       * Math utility functions (missing from standard Math object)
       */
      Math.scale = function (value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
      };

      Math.clamp = function (value, min, max) {
        return Math.max(min, Math.min(max, value));
      };

      /**
       * Sigmoid utility function
       */
      function sigmoidFactory(k) {
        function base(t) {
          return 1 / (1 + Math.exp(-k * t)) - 0.5;
        }

        var correction = 0.5 / base(1);

        return function (t) {
          t = Math.clamp(t, 0, 1);
          return correction * base(2 * t - 1) + 0.5;
        };
      }

      const Sigmoid = sigmoidFactory;

      /**
       * Color utilities
       */
      const ampColors = [
        [0, 0, 0], // black
        [86, 167, 84], // green
        [237, 217, 41], // yellow
        [227, 48, 89], // red
      ];

      function amp2Color(amp, noBlack = false, exp = 0.7) {
        const scaledAmp = Math.clamp(Math.pow(amp, exp), 0, 1);
        const index = Math.scale(scaledAmp, 0, 1, 0, ampColors.length - 1);
        const a0 = Math.floor(index);
        const a1 = Math.ceil(index);
        const percent = a0 !== ampColors.length - 1 ? index - a0 : 1;

        const color0 = ampColors[a0];
        const color1 = ampColors[a1];

        const r = Math.round(color0[0] + (color1[0] - color0[0]) * percent);
        const g = Math.round(color0[1] + (color1[1] - color0[1]) * percent);
        const b = Math.round(color0[2] + (color1[2] - color0[2]) * percent);

        return {
          css: () => `rgb(${r}, ${g}, ${b})`,
        };
      }

      /**
       * Base Visualization class
       */
      class Visualization {
        constructor(name) {
          this._canvas = document.createElement("canvas");
          this._context = this._canvas.getContext("2d");
          this._lastUpdate = performance.now();
          this.name = name;
        }

        get opacity() {
          return this._context.globalAlpha;
        }

        set opacity(o) {
          this._context.globalAlpha = o;
        }

        get canvas() {
          return this._canvas;
        }

        get context() {
          return this._context;
        }

        clear() {
          this._context.clearRect(0, 0, this.width, this.height);
        }

        resize(width, height) {
          this.width = width;
          this.height = height;
          this._canvas.width = this.width;
          this._canvas.height = this.height;
        }

        draw() {}

        drawTo(context, x = 0, y = 0) {
          this.draw(this._context, this.width, this.height);
          context.drawImage(this.canvas, x, y, this.width, this.height);
        }
      }

      /**
       * OnionSkin Visualization (adds trailing effect)
       */
      class OnionSkinVisualization extends Visualization {
        constructor(name) {
          super(name);
          this._swapViz = new Visualization("swap canvas");
          this.history = 0.95;
        }

        resize(width, height) {
          super.resize(width, height);
          this._swapViz.resize(width, height);
        }

        drawTo(context, x = 0, y = 0) {
          if (this.history > 0) {
            this.context.clearRect(0, 0, this.width, this.height);
            this.context.globalAlpha = this.history;
            this.context.drawImage(
              this._swapViz.canvas,
              0,
              0,
              this.width,
              this.height
            );
            this.context.globalAlpha = 1;

            this.draw(this.context, this.width, this.height);

            this._swapViz.context.clearRect(0, 0, this.width, this.height);
            this._swapViz.context.drawImage(
              this.canvas,
              0,
              0,
              this.width,
              this.height
            );
            context.drawImage(this.canvas, x, y, this.width, this.height);
          } else {
            this.context.clearRect(0, 0, this.width, this.height);
            super.drawTo(context, x, y);
          }
        }
      }

      /**
       * HilbertScope class (audio processing using Web Audio API)
       */
      class HilbertScope {
        constructor(length = 1024) {
          this.length = length;
          this.audioContext = null;
          this.input = null;
          this.analyser = null;
          this.gainNode = null;
          this.delayNode = null;
          this.convolverNode = null;
          this.timeData = new Float32Array(length);
          this.quadData = new Float32Array(length);
        }

        async connect(audioContext, sourceNode) {
          this.audioContext = audioContext;

          // Create gain node for input
          this.gainNode = audioContext.createGain();
          sourceNode.connect(this.gainNode);

          // Create analysers for time and quadrature data
          this.timeAnalyser = audioContext.createAnalyser();
          this.quadAnalyser = audioContext.createAnalyser();

          this.timeAnalyser.fftSize = this.length * 2;
          this.quadAnalyser.fftSize = this.length * 2;

          // Create Hilbert transform filter
          const [delay, hilbert] = this._createFilters(audioContext);

          // Connect the audio graph
          this.gainNode.connect(hilbert);
          this.gainNode.connect(delay);

          hilbert.connect(this.timeAnalyser);
          delay.connect(this.quadAnalyser);
        }

        _createFilters(audioContext) {
          let filterLength = 768;
          if (filterLength % 2 === 0) {
            filterLength -= 1;
          }

          let impulse = new Float32Array(filterLength);
          let mid = ((filterLength - 1) / 2) | 0;

          for (let i = 0; i <= mid; i++) {
            // Hamming window
            let k = 0.53836 + 0.46164 * Math.cos((i * Math.PI) / (mid + 1));
            if (i % 2 === 1) {
              let im = 2 / Math.PI / i;
              impulse[mid + i] = k * im;
              impulse[mid - i] = k * -im;
            }
          }

          // Create convolver for Hilbert transform
          let impulseBuffer = audioContext.createBuffer(
            1,
            filterLength,
            audioContext.sampleRate
          );
          impulseBuffer.copyToChannel(impulse, 0);
          let hilbert = audioContext.createConvolver();
          hilbert.normalize = false;
          hilbert.buffer = impulseBuffer;

          // Create delay to compensate for Hilbert transform delay
          let delayTime = mid / audioContext.sampleRate;
          let delay = audioContext.createDelay(delayTime);
          delay.delayTime.value = delayTime;

          return [delay, hilbert];
        }

        getValues() {
          if (this.timeAnalyser && this.quadAnalyser) {
            this.timeAnalyser.getFloatTimeDomainData(this.timeData);
            this.quadAnalyser.getFloatTimeDomainData(this.quadData);
          }
          return [this.timeData, this.quadData];
        }
      }

      /**
       * Hilbert base class
       */
      class Hilbert extends OnionSkinVisualization {
        constructor(source) {
          super("Hilbert Scope");

          this._scope = new HilbertScope(1024);
          this.history = 0.95;
          this._sigmoid = Sigmoid(7);
          this.color = "white";
          this._source = source;
        }

        async connectAudio(audioContext, sourceNode) {
          await this._scope.connect(audioContext, sourceNode);
        }

        _scaleVal(val) {
          const scaledVal = Math.scale(val, -3, 3, 0, 1);
          return Math.scale(this._sigmoid(scaledVal), 0, 1, -1, 1);
        }

        draw(context, width, height) {
          const [xVals, yVals] = this._scope.getValues();
          const amp = this._source.getAmplitude();

          context.beginPath();
          context.lineWidth = Math.scale(amp, 0, 1, 2, 10);

          for (let i = 0; i < xVals.length; i++) {
            let x = xVals[i];
            let y = yVals[i];
            const centerX = width / 2;
            const centerY = height / 2;
            const scalar = height / 2;
            x = this._scaleVal(x) * scalar + centerX;
            y = this._scaleVal(y) * scalar + centerY;

            if (i === 0) {
              context.moveTo(x, y);
            } else {
              context.lineTo(x, y);
            }
          }

          context.strokeStyle = this.color;
          context.stroke();
        }
      }

      /**
       * HilbertAmplitude class (final visualization)
       */
      class HilbertAmplitude extends Hilbert {
        constructor(source) {
          super(source);
          this.history = 0.85;
          this.fullColor = false; // Set to true to enable amplitude-based coloring
        }

        draw(context, width, height) {
          if (this.fullColor) {
            const amp = this._source.getAmplitude();
            this.color = amp2Color(amp, false, 0.5).css();
          } else {
            this.color = "white";
          }

          super.draw(context, width, height);
        }
      }

      /**
       * Amplitude analyzer
       */
      class Amplitude {
        constructor(audioContext, sourceNode) {
          this.audioContext = audioContext;
          this.analyser = audioContext.createAnalyser();
          this.analyser.fftSize = 256;
          this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
          sourceNode.connect(this.analyser);
        }

        getAmplitude() {
          this.analyser.getByteFrequencyData(this.dataArray);
          let sum = 0;
          for (let i = 0; i < this.dataArray.length; i++) {
            sum += this.dataArray[i];
          }
          const average = sum / this.dataArray.length;
          return Math.pow(average / 255, 0.8);
        }
      }

      /**
       * Mock source object that provides amplitude data
       */
      class MockAudioSource {
        constructor(amplitude) {
          this.amplitude = amplitude;
        }

        getAmplitude() {
          return this.amplitude.getAmplitude();
        }

        connect(node) {
          // This is handled by the actual Web Audio connections
        }
      }

      /**
       * Main Application with Tone.js
       */
      class HilbertScopeToneApp {
        constructor() {
          this.canvas = document.getElementById("canvas");
          this.context = this.canvas.getContext("2d");
          this.startBtn = document.getElementById("startBtn");
          this.stopBtn = document.getElementById("stopBtn");
          this.status = document.getElementById("status");
          this.keyboard = document.getElementById("keyboard");
          this.volumeSlider = document.getElementById("volumeSlider");
          this.volumeValue = document.getElementById("volumeValue");
          this.octaveSelect = document.getElementById("octaveSelect");

          this.synth = null;
          this.gain = null;
          this.amplitude = null;
          this.visualization = null;
          this.isRunning = false;
          this.activeNotes = new Set();

          this.setupKeyboard();
          this.setupEventListeners();
          this.resize();
        }

        setupKeyboard() {
          // Define keyboard layout
          const keys = [
            { note: "C", type: "white", keyCode: "A" },
            { note: "C#", type: "black", keyCode: "W" },
            { note: "D", type: "white", keyCode: "S" },
            { note: "D#", type: "black", keyCode: "E" },
            { note: "E", type: "white", keyCode: "D" },
            { note: "F", type: "white", keyCode: "F" },
            { note: "F#", type: "black", keyCode: "T" },
            { note: "G", type: "white", keyCode: "G" },
            { note: "G#", type: "black", keyCode: "Y" },
            { note: "A", type: "white", keyCode: "H" },
            { note: "A#", type: "black", keyCode: "U" },
            { note: "B", type: "white", keyCode: "J" },
          ];

          // Create visual keyboard
          keys.forEach((key, index) => {
            const keyEl = document.createElement("div");
            keyEl.className = `key ${key.type}`;
            keyEl.textContent = key.note;
            keyEl.dataset.note = key.note;
            keyEl.dataset.keyCode = key.keyCode.toLowerCase();

            keyEl.addEventListener("mousedown", () => this.playNote(key.note));
            keyEl.addEventListener("mouseup", () => this.stopNote(key.note));
            keyEl.addEventListener("mouseleave", () => this.stopNote(key.note));

            this.keyboard.appendChild(keyEl);
          });

          // Computer keyboard support
          document.addEventListener("keydown", (e) => {
            if (!this.isRunning) return;
            const keyEl = document.querySelector(
              `[data-key-code="${e.key.toLowerCase()}"]`
            );
            if (keyEl && !e.repeat) {
              this.playNote(keyEl.dataset.note);
            }
          });

          document.addEventListener("keyup", (e) => {
            if (!this.isRunning) return;
            const keyEl = document.querySelector(
              `[data-key-code="${e.key.toLowerCase()}"]`
            );
            if (keyEl) {
              this.stopNote(keyEl.dataset.note);
            }
          });
        }

        setupEventListeners() {
          this.startBtn.addEventListener("click", () => this.startAudio());
          this.stopBtn.addEventListener("click", () => this.stopAudio());
          window.addEventListener("resize", () => this.resize());

          this.volumeSlider.addEventListener("input", (e) => {
            const volume = e.target.value;
            this.volumeValue.textContent = volume + "%";
            if (this.gain) {
              // Convert percentage to dB
              const db = Math.log10(volume / 100) * 20;
              this.gain.gain.rampTo(db, 0.05);
            }
          });
        }

        resize() {
          const rect = this.canvas.getBoundingClientRect();
          this.canvas.width = 800;
          this.canvas.height = 600;

          if (this.visualization) {
            this.visualization.resize(this.canvas.width, this.canvas.height);
          }
        }

        playNote(note) {
          if (!this.isRunning || this.activeNotes.has(note)) return;

          const octave = this.octaveSelect.value;
          const fullNote = note + octave;

          this.activeNotes.add(note);
          this.synth.triggerAttack(fullNote);

          // Visual feedback
          const keyEl = document.querySelector(`[data-note="${note}"]`);
          if (keyEl) keyEl.classList.add("active");
        }

        stopNote(note) {
          if (!this.isRunning || !this.activeNotes.has(note)) return;

          const octave = this.octaveSelect.value;
          const fullNote = note + octave;

          this.activeNotes.delete(note);
          this.synth.triggerRelease(fullNote);

          // Remove visual feedback
          const keyEl = document.querySelector(`[data-note="${note}"]`);
          if (keyEl) keyEl.classList.remove("active");
        }

        async startAudio() {
          try {
            this.status.textContent = "Initializing Tone.js...";

            // Start Tone.js
            await Tone.start();

            // Create synth with triangle wave for smoother visualization
            this.synth = new Tone.PolySynth(Tone.Synth, {
              oscillator: {
                type: "sine",
              },
              envelope: {
                attack: 0.02,
                decay: 0.1,
                sustain: 0.3,
                release: 0.8,
              },
            });

            // Create gain node for volume control
            this.gain = new Tone.Gain(0.75);

            // Connect audio chain
            this.synth.connect(this.gain);
            this.gain.toDestination();

            // Get the Web Audio context from Tone.js
            const audioContext = Tone.context;

            // Create a native Web Audio gain node to connect to our analyzers
            const nativeGain = audioContext.createGain();

            // Connect Tone.js gain to native gain node
            this.gain.connect(nativeGain);

            // Create amplitude analyzer
            this.amplitude = new Amplitude(audioContext, nativeGain);

            // Create mock source for visualization
            const mockSource = new MockAudioSource(this.amplitude);

            // Create visualization
            this.visualization = new HilbertAmplitude(mockSource);
            await this.visualization.connectAudio(audioContext, nativeGain);
            this.visualization.resize(this.canvas.width, this.canvas.height);

            // Start animation
            this.isRunning = true;
            this.animate();

            // Update UI
            this.startBtn.disabled = true;
            this.stopBtn.disabled = false;
            this.status.textContent =
              "Ready to play! Click the keys or use your keyboard.";
          } catch (error) {
            console.error("Error starting audio:", error);
            this.status.textContent = "Error: " + error.message;
          }
        }

        stopAudio() {
          this.isRunning = false;

          // Clean up all active notes
          this.activeNotes.forEach((note) => {
            const keyEl = document.querySelector(`[data-note="${note}"]`);
            if (keyEl) keyEl.classList.remove("active");
          });
          this.activeNotes.clear();

          // Dispose Tone.js objects
          if (this.synth) {
            this.synth.dispose();
            this.synth = null;
          }

          if (this.gain) {
            this.gain.dispose();
            this.gain = null;
          }

          this.amplitude = null;
          this.visualization = null;

          // Clear canvas
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Update UI
          this.startBtn.disabled = false;
          this.stopBtn.disabled = true;
          this.status.textContent =
            'Stopped - click "Start Audio" to begin again';
        }

        animate() {
          if (!this.isRunning) return;

          requestAnimationFrame(() => this.animate());

          if (this.visualization) {
            // Clear canvas
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw visualization
            this.visualization.drawTo(this.context);
          }
        }
      }

      // Initialize the app when the page loads
      document.addEventListener("DOMContentLoaded", () => {
        new HilbertScopeToneApp();
      });
    </script>
  </body>
</html>
